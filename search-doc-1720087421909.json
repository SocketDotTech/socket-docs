[{"title":"Receiving messages","type":0,"sectionRef":"#","url":"/Build/contract-setup/receiving","content":"Receiving messages Plugs on destination network need to implement inbound() to handle incoming messages. Socket calls the inbound function on the destination Plug when sending the payload. The inbound() should follow the interface mentioned in the interface mentioned here. interface IPlug { /** * @notice executes the message received from source chain * @dev this should be only executable by socket * @param siblingChainSlug_ chain slug of source * @param payload_ the data which is needed by plug at inbound call on destination */ function inbound( uint32 siblingChainSlug_, bytes calldata payload_ ) external; } note Only Socket on a given chain should be allowed to call the inbound method on a Plug as seen in the example below. Your Plug on the destination network can look something like below. In the below snippet we assume the payload is a uint256. uint256 number; function inbound( uint32 siblingChainSlug_, bytes calldata payload_ ) external payable { // Make sure the caller is Socket contract only require(msg.sender == address(socket), &quot;Not Socket&quot;); // you can do anything in this function // payload can be decoded to do anything number = abi.decode(payload) } ","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"App Chain Bridge","type":0,"sectionRef":"#","url":"/Build/ExampleSection/app-chain-bridge","content":"App Chain Bridge App Chain Bridge is a custom token bridge for App Chains or custom roll-ups. The bridge can be setup as a Lock-Mint bridge for existing tokens or a Burn-Mint bridge for tokens supporting Universal ERC20s App Chain Bridge (SuperBridge) in production powering USDC bridging on Aevo's Optimistic App-Chain App Chain Bridge ","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Sending messages","type":0,"sectionRef":"#","url":"/Build/contract-setup/sending","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Parameters​","type":1,"pageTitle":"Sending messages","url":"/Build/contract-setup/sending#parameters","content":"Parameters\tDescriptionremoteChainSlug\tChainSlug of the network where you want to send your message to payload\tThe message you want to send to the plug on remoteChainSlug msgGasLimit\tgasLimit required to execute the payload on remoteChainSlug In order to pay for cross-chain execution, you call the outbound function with the msg.value representing the amount of fees you want to pay. You can estimate the minimum amount of fees via the methods outlined here. ","version":"Next","tagName":"h2"},{"title":"Sending your message​","type":1,"pageTitle":"Sending messages","url":"/Build/contract-setup/sending#sending-your-message","content":"Make sure you have connected your Plugs on both chains to each other before you call the outbound method Equipped with the payload we want to send, we can now call the outbound on Socket, below is a quick example  // Get Socket address from the deployments page for your network ISocket socket = ISocket(_address); // THIS IS NOT AN ACTUAL SLUG, please get the right slug from the deployments page uint32 remoteChainSlug = 1333; uint32 defaultGasLimit = 1000000; // send hello world to the sibling Plug we configured on chainSlug:1333 function SendHelloWorld( ) external payable { bytes memory payload = abi.encode(&quot;Hello World&quot;); // msg.value should be equal to the minFees socket.outbound{value: msg.value}(remoteChainSlug, defaultGasLimit, bytes32(0), bytes32(0), payload); }  Once the tx is finalised: An event MessageOutbound is emitted by Socket containing all relevant details.Your message will be allocated a unique ID called (msgId) you can look it up in the MessageOutbound log You can use the tx-hash to track the delivery and execution on the destination chain via this API. ","version":"Next","tagName":"h2"},{"title":"Configuring Plugs","type":0,"sectionRef":"#","url":"/Build/contract-setup/configuring-plugs","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Configuring Plug Parameters​","type":1,"pageTitle":"Configuring Plugs","url":"/Build/contract-setup/configuring-plugs#configuring-plug-parameters","content":"Plugs should be deployed on respective chains before they can be connected to their sibling Plugs deployed on other chains. Once you are ready with Plugs deployed on the networks you want to work with, it's time to get Plugged! Here's the parameters required for connection Parameters\tDescriptionsiblingChainSlug\tChainSlug of the network the sibling plug is deployed on, you can find all chainSlugs here siblingPlug\tAddress of the plug deployed on the sibling chain inboundSwitchboard\tSwitchboard address used for receiving messages from siblingPlug outboundSwitchboard\tSwitchboard address used for sending messages to siblingPlug You can find addresses for all verified Switchboards and Socket contracts in Deployments ","version":"Next","tagName":"h2"},{"title":"Connecting your Plugs​","type":1,"pageTitle":"Configuring Plugs","url":"/Build/contract-setup/configuring-plugs#connecting-your-plugs","content":"Once you have the Socket address you are connecting to, you just need to call the connect method on it to configure your Plug on that chain. Remember, you need to call connect on both the chains you want to work with. Below is a quick example for how your Plug can call the connect method on Socket  ISocket socket = ISocket(socket_address); function connectToSocket( uint32 siblingChainSlug, address siblingPlug, address inboundSwitchboard, address outboundSwitchboard ) external { // ensure its permissioned require(msg.sender == AUTHORISED_CONNECTOR, &quot;Caller is not authorised to make make connections&quot;); // finally just call the socket to connect socket.connect( siblingChainSlug, siblingPlug, inboundSwitchboard, outboundSwitchboard ); }  ","version":"Next","tagName":"h2"},{"title":"Testing your connection​","type":1,"pageTitle":"Configuring Plugs","url":"/Build/contract-setup/configuring-plugs#testing-your-connection","content":"Once you are done connecting, the transaction will emit a log called PlugConnected For reference, checkout this example tx of connecting a Plug  Furthermore, you can do the following to check the connection is successful : Call the getPlugConfig function on the Socket contract that returns the config for your Plug for a given destination ChainSlugUse the Check Connection API that reads the configs and aids you to make sure your connection is correct ","version":"Next","tagName":"h2"},{"title":"More Examples","type":0,"sectionRef":"#","url":"/Build/ExampleSection/dl-examples","content":"More Examples We have built a few examples and templates to make building on SocketDL easier. You can find all of them in the SocketDL-examples repo. Examples​ App Chain TokenHello WorldCross-chain CounterPing PongUniversal ERC-20Universal ERC-721ProCounter Templates​ UnicastPlugBaseBatchPlugBaseSourceSenderPlugBaseBroadcastPlugBaseSequentialPlugBase","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Universal ERC20","type":0,"sectionRef":"#","url":"/Build/ExampleSection/example-uniERC20","content":"Universal ERC20 Universal ERC-20 is an extension of ERC-20 token standard with cross-chain transfer capabilities, built on top of SocketDL. Universal ERC-20 has cross-chain transfers built-in. When sending the token between chains, it gets burnt on the sending chain and minted on the destination chain. You can find the example on GitHub. /* Burns user tokens on source chain and sends mint message on destination chain */ function uniTransfer( uint256 _destChainSlug, address _destReceiver, uint256 _amount ) external payable { _burn(msg.sender, _amount); bytes memory payload = abi.encode(msg.sender, _destReceiver, _amount); ISocket(socket).outbound{value: msg.value}( _destChainSlug, destGasLimits[_destChainSlug], bytes32(0), bytes32(0), payload ); emit UniTransfer(_destChainSlug, _destReceiver, _amount); } /* Decodes destination data and mints equivalent tokens burnt on source chain */ function _uniReceive( uint256 siblingChainSlug_, bytes calldata payload_ ) internal { (address _sender, address _receiver, uint256 _amount) = abi.decode( payload_, (address, address, uint256) ); _mint(_receiver, _amount); emit UniReceive(_sender, _receiver, _amount, siblingChainSlug_); } ","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Universal ERC721","type":0,"sectionRef":"#","url":"/Build/ExampleSection/example-uniERC721","content":"Universal ERC721 Universal ERC-721 is an extension of ERC-721 token standard with cross-chain transfer capabilities, built on top of SocketDL. You can find the example on GitHub. /* Transfers tokens between chains */ function uniTransfer( uint256 _destChainSlug, address _destReceiver, uint256 tokenId ) external payable { _burn(tokenId); bytes memory payload = abi.encode(msg.sender, _destReceiver, tokenId); ISocket(socket).outbound{value: msg.value}( _destChainSlug, destGasLimits[_destChainSlug], bytes32(0), bytes32(0), payload ); emit UniTransfer(_destChainSlug, _destReceiver, tokenId); } function _uniReceive( uint256 _siblingChainSlug, address _sender, address _receiver, uint256 _tokenId ) internal { _safeMint(_receiver, _tokenId); emit UniReceive(_sender, _receiver, _tokenId, _siblingChainSlug); } ","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Testing integration","type":0,"sectionRef":"#","url":"/Build/testing-dl","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"MockSocket​","type":1,"pageTitle":"Testing integration","url":"/Build/testing-dl#mocksocket","content":"","version":"Next","tagName":"h3"},{"title":"Testing integration locally​","type":1,"pageTitle":"Testing integration","url":"/Build/testing-dl#testing-integration-locally","content":"MockSocket is a test tool that Plugs can use to test their integration with Socket. MockSocket simulates the functionality of Socket without actually sending a cross-chain message. It does this by calling the inbound method on the Plug directly when an outbound message transaction is initiated. Plugs can use MockSocket to test their SC integration with Socket. Find example tests that utilise MockSocket in SocketDL-examples. Plugs can assert the intended state changes on the destination chain and verify successful execution of the message. MockSocket is not an E2E testing solution for message delivery on Plugs. It does not account for validity of message, gasPrice hikes on blockchains etc. For E2E testing, Plugs can be deployed on any supported testnets. ","version":"Next","tagName":"h3"},{"title":"Testing Plug connection​","type":1,"pageTitle":"Testing integration","url":"/Build/testing-dl#testing-plug-connection","content":"API​ The Check Connection helper API can be used to verify a connection is successfully established between two Plugs. On-chain​ Once the connection step is complete, you can verify the connection was successful by calling the getPlugConfig() method on Socket. This is a view function that returns the config of the plug for a given remote chain. If it returns the config, then the Plug connection is successful. /* EXAMPLE TO RETURN GOERLI PLUG CONFIG FOR CONNECTION MUMBAI TESTNET CHAIN 5 PLUG ADDRESS : 0x876B15bc0963C3c1AcA50Adfc0685A458449E41d SIBLING CHAIN ID : 80001 This script returns the configuration of a Plug for a given sibling chain */ const { Contract, providers } = require(&quot;ethers&quot;); // SOCKET CONFIG const ABI = [ &quot;function getPlugConfig(address plugAddress_, uint256 siblingChainSlug_) view returns (address siblingPlug, address inboundSwitchboard__, address outboundSwitchboard__, address capacitor__, address decapacitor__)&quot; ]; const RPC = &quot;https://rpc.ankr.com/eth_goerli&quot;; const CONTRACT_ADDRESS = &quot;0xA78426325b5e32Affd5f4Bc8ab6575B24DCB1762&quot;; // PLUG CONFIG const PLUG_ADDRESS = &quot;0x876B15bc0963C3c1AcA50Adfc0685A458449E41d&quot;; const SIBLING_CHAIN_SLUG = 80001; const main = async () =&gt; { const provider = new providers.JsonRpcProvider(RPC); const contract = new Contract(CONTRACT_ADDRESS, ABI, provider); const plugConfig = await contract.getPlugConfig(PLUG_ADDRESS, SIBLING_CHAIN_SLUG); console.log(plugConfig); } main();  ","version":"Next","tagName":"h3"},{"title":"Speed Run DL","type":0,"sectionRef":"#","url":"/Build/hello-world","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Step 1 : Boilerplate code​","type":1,"pageTitle":"Speed Run DL","url":"/Build/hello-world#step-1--boilerplate-code","content":"Below is the boilerplate code needed to get started. ISocket is the interface used by our contract to interact with Socket. Hello World is the contract which we'll be writing to send/receive messages. // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; interface ISocket { function outbound( uint32 remoteChainSlug_, uint256 minMsgGasLimit_, bytes32 executionParams_, bytes32 transmissionParams_, bytes calldata payload_ ) external payable returns (bytes32 msgId); function connect( uint32 siblingChainSlug_, address siblingPlug_, address inboundSwitchboard_, address outboundSwitchboard_ ) external; function getMinFees( uint256 minMsgGasLimit_, uint256 payloadSize_, bytes32 executionParams_, bytes32 transmissionParams_, uint32 remoteChainSlug_, address plug_ ) external view returns (uint256 totalFees); } contract HelloWorld { }  ","version":"Next","tagName":"h3"},{"title":"Step 2 : Initialise state variables, events, modifiers​","type":1,"pageTitle":"Speed Run DL","url":"/Build/hello-world#step-2--initialise-state-variables-events-modifiers","content":"State variables​ message is the message which will be set on the remote plug destGasLimit is the gas limit of setting the message on the destination chain, this value varies depending on the chain. You can learn more about the other variables in Configuring Plugs Events​ MessageSent is emitted when a message is sent from the source plug and MessageReceived is emitted when the message is received on the destination plug.  string public message = &quot;Hello World&quot;; address owner; /** * @dev Hardcoded values for Goerli */ uint256 destGasLimit = 100000; // Gas cost of sending &quot;Hello World&quot; on Mumbai uint32 public remoteChainSlug = 80001; // Mumbai testnet chain ID address public socket = 0xe37D028a77B4e6fCb05FC75EBa845752cD62A0AA; // Socket Address on Goerli address public inboundSwitchboard = 0xd59d596B7C7cB4593F61bbE4A82C1E943C64558D; // FAST Switchboard on Goerli address public outboundSwitchboard = 0xd59d596B7C7cB4593F61bbE4A82C1E943C64558D; // FAST Switchboard on Goerli event MessageSent(uint32 destChainSlug, string message); event MessageReceived(uint32 srcChainSlug, string message); modifier isOwner() { require(msg.sender == owner, &quot;Not owner&quot;); _; } modifier isSocket() { require(msg.sender == socket, &quot;Not Socket&quot;); _; } error InsufficientFees(); constructor() { owner = msg.sender; }  ","version":"Next","tagName":"h3"},{"title":"Step 3 : Config Functions​","type":1,"pageTitle":"Speed Run DL","url":"/Build/hello-world#step-3--config-functions","content":"connectPlug function connects our Hello World Plug to its sibling Plug on another chain. This connection is required for the Plugs to send/receive messages from one another.  function connectPlug(address siblingPlug_) external isOwner { ISocket(socket).connect( remoteChainSlug, siblingPlug_, inboundSwitchboard, outboundSwitchboard ); }  ","version":"Next","tagName":"h3"},{"title":"Step 4 : Sending messages​","type":1,"pageTitle":"Speed Run DL","url":"/Build/hello-world#step-4--sending-messages","content":"sendMessage sends the &quot;Hello World&quot; message to the remote chain. This function calls Socket and initiates the outbound cross-chain message _getMinimumFees fetches the fees for including messages in Packets &amp; executing them. This can be used to verify sufficient fees are passed when sending the message. You can learn more about this in Fees.  function sendMessage() external payable { bytes memory payload = abi.encode(message); uint256 totalFees = _getMinimumFees(destGasLimit, payload.length); if (msg.value &lt; totalFees) revert InsufficientFees(); ISocket(socket).outbound{value: msg.value}( remoteChainSlug, destGasLimit, bytes32(0), bytes32(0), payload ); emit MessageSent(remoteChainSlug, message); } function _getMinimumFees( uint256 minMsgGasLimit_, uint256 payloadSize_ ) internal view returns (uint256) { return ISocket(socket).getMinFees( minMsgGasLimit_, payloadSize_, bytes32(0), bytes32(0), remoteChainSlug, address(this) ); }  ","version":"Next","tagName":"h3"},{"title":"Step 5 : Receiving Messages​","type":1,"pageTitle":"Speed Run DL","url":"/Build/hello-world#step-5--receiving-messages","content":"inbound is called by Socket on the destination Plug for executing the message once it's verified. More in this in Lifecycle _receiveMessage sets the value of the new message and emits the MessageReceived event  function _receiveMessage( uint32 _srcChainSlug, string memory _message ) internal { message = _message; emit MessageReceived(_srcChainSlug, _message); } function inbound( uint32 srcChainSlug_, bytes calldata payload_ ) external isSocket { string memory _message = abi.decode(payload_, (string)); _receiveMessage(srcChainSlug_, _message); }  ","version":"Next","tagName":"h3"},{"title":"Step 6 : Deploying contracts​","type":1,"pageTitle":"Speed Run DL","url":"/Build/hello-world#step-6--deploying-contracts","content":"We'll be deploying the same contract on Goerli and Mumbai testnets. However, to make it easier to send our first message, we've hardcoded some configuration variables specific to Goerli and Mumbai. Click the links below to deploy each of them Goerli​ 🚀 Deploy Goerli contract on Remix 📄 Goerli contract on GitHub Mumbai​ 🚀 Deploy Mumbai contract on Remix 📄 Mumbai contract on GitHub You can head over to Remix and compile the code for SpeedRunGoerli  Then, deploy it    You'll then have to deploy the SpeedRunMumbai contract following the same steps. ","version":"Next","tagName":"h3"},{"title":"Step 7 : Configuration​","type":1,"pageTitle":"Speed Run DL","url":"/Build/hello-world#step-7--configuration","content":"Once you've deployed the contracts on Goerli and Mumbai, call the connectPlug function with the address of the contract deployed on the other chain. You need to do this on both contracts deployed on respective chains.    For instance, on Goerli you would call connectPlug with the address of the contract deployed on Mumbai and vice-versa. This establishes a connection between the two Plugs deployed and you can now send messages between them! ","version":"Next","tagName":"h3"},{"title":"Step 8 : Hello World​","type":1,"pageTitle":"Speed Run DL","url":"/Build/hello-world#step-8--hello-world","content":"To send your first message, call the sendMessage function on Goerli. You need to send a fee in ETH as value when calling sendMessage. This fee can be calculated using the Fee Estimate API https://surge.dlapi.socket.tech/estimate-fees?srcChainSlug=5&amp;dstChainSlug=80001&amp;integrationType=FAST&amp;msgGasLimit=100000 You can enter the totalFee returned by this API as value when sending the transaction    That's it! You can now track the status of your message using the Status Tracking API. Once your message is executed on Mumbai, you'll be able to see the message value set to &quot;Hello World&quot; on Mumbai.    You're Plugged! You've successfully sent your first message via SocketDL. Explore more in Tutorials and Examples. ","version":"Next","tagName":"h3"},{"title":"Track Message Status","type":0,"sectionRef":"#","url":"/dev-resources/APIReference/track-status","content":"Track Message Status Tracks the status of a message GET https://prod.dlapi.socket.tech/v1/messages-from-tx Header: x-api-key : 2Va1n3HzAS5XfXB8ELhX1aATJwzA1A72sNnJE1a0 Query Parameters​ Query param\tDescriptionsrcChainSlug\tSlug of source chain srcTxHash\tTransaction hash where outbound method was called Example Request​ https://prod.dlapi.socket.tech/v1/messages-from-tx?srcChainSlug=10&amp;srcTxHash=0xc3243233916c25f0455a9440fcd2183d49858149ad103c6ff8d6167d812bc0dc Note : Add the x-api-key header mentioned above in the request for authentication. Response Parameters​ Parameter\tDescriptionstatus\tMessage Status messageId\tUnique ID of message packetId\tUnique ID assigned to each Packet from.srcChainSlug\tSlug of source chain where message is initiated from.srcPlug\tAddress of message sender plug to.dstChainSlug\tSlug of destination chain where message is executed to.destPlug\tAddress of message receiver plug outboundTx\tSource chain transaction hash where outbound method was called packedMessage\tkeccak256 hash of encoded message details inboundTx\tTransaction on destination chain where the inbound method on Socket is called executionDetails.inboundStatus\tStatus of executing inbound method on destination Plug InboundStatus executionDetails.isExecuted\tBoolean value indicating if message is executed on destination chain executionDetails.executor\tAddress of Executor executionDetails.executionTxHash\tDestination chain transaction hash where payload was executed Types of messageStatus​ Type\tDescriptionRECEIVED\tMessage added to capacitor queue for destination chain delivery SEALED\tPacket which includes the message has been sealed on source chain PROPOSED\tPacket which includes the message has been proposed on destination chain ATTESTED\tThe validity of the packet has been attested or verified on the destination chain VERIFIED\tThe message has been verified EXECUTING\tThe message is being executed EXECUTION_FAILURE\tMessage execution failed EXECUTION_SUCCESS\tMessage is successfully delivered to destination Plug INBOUND_REVERTING\tThe inbound method on the destination chain plug is reverting Inbound status​ Type\tDescriptionNOT_TRIED\tPayload execution not been tried yet REVERTING\tPayload execution is reverting on Plug's inbound method call EXECUTING\tPayload execution tx sent and is in progress SUCCESS\tinbound method called and payload successfully executed","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Check Connection","type":0,"sectionRef":"#","url":"/dev-resources/APIReference/check-connection","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"On-chain​","type":1,"pageTitle":"Check Connection","url":"/dev-resources/APIReference/check-connection#on-chain","content":"The connection can be verified on-chain by calling the getPlugConfig() method on Socket. More on this here. ","version":"Next","tagName":"h2"},{"title":"Off-chain​","type":1,"pageTitle":"Check Connection","url":"/dev-resources/APIReference/check-connection#off-chain","content":"GET https://prod.dlapi.socket.tech/v1/check-connection Header: x-api-key : 2Va1n3HzAS5XfXB8ELhX1aATJwzA1A72sNnJE1a0 Query Param\tDescriptionslugA\tChain A slug slugB\tChain B slug plugA\tAddress of Plug on Chain A plugB\tAddress of Plug on Chain B Example Request​ Verifying a connection between Plugs deployed on Goerli and Mumbai testnet https://prod.dlapi.socket.tech/v1/check-connection?slugA=2999&amp;slugB=10&amp;plugA=0x7b9ed5C43E87DAFB03211651d4FA41fEa1Eb9b3D&amp;plugB=0x1812ff6bd726934f18159164e2927B34949B16a8 Note : Add the x-api-key header mentioned above in the request for authentication. Response Parameters​ Parameter\tDescriptionarePlugsConnected\tBoolean value indicating if there's an active connection between Plugs aToBIntegrationType\tReturns type of switchboard used for connection from PlugA to PlugB (FAST, SLOW, NATIVE) bToAIntegrationType\tReturns type of switchboard used for connection from PlugB to PlugA (FAST, SLOW, NATIVE) ","version":"Next","tagName":"h2"},{"title":"Estimate Fees","type":0,"sectionRef":"#","url":"/dev-resources/APIReference/estimate-fees","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"On-chain​","type":1,"pageTitle":"Estimate Fees","url":"/dev-resources/APIReference/estimate-fees#on-chain","content":"The fees for relaying messages can be calculated on-chain by calling the getMinFees() method on Socket. The method can be inherited in your contract from the ISocket interface.  interface ISocket { function getMinFees( uint256 minMsgGasLimit_, uint256 payloadSize_, bytes32 executionParams_, bytes32 transmissionParams_, uint32 remoteChainSlug_, address plug_ ) external view returns (uint256 totalFees); }  Example​ The SpeedRunDL example contract fetches the fee on-chain and checks if the fee sent from the user is correct.  function _getMinimumFees( uint256 msgGasLimit_, uint32 _remoteChainSlug ) internal view returns (uint256) { return ISocket(socket).getMinFees( msgGasLimit_, _remoteChainSlug, address(this) ); } function sendMessage() external payable { uint256 totalFees = _getMinimumFees(destGasLimit, remoteChainSlug); if (msg.value &lt; totalFees) revert InsufficientFees(); // ... remaining code }  ","version":"Next","tagName":"h2"},{"title":"Off-chain API​","type":1,"pageTitle":"Estimate Fees","url":"/dev-resources/APIReference/estimate-fees#off-chain-api","content":"GET https://prod.dlapi.socket.tech/v1/estimate-min-fees Header: x-api-key : 2Va1n3HzAS5XfXB8ELhX1aATJwzA1A72sNnJE1a0 Query Param\tDescriptionsrcPlug\tAddress of source Plug srcChainSlug\tSlug of source chain dstChainSlug\tSlug of destination chain msgGasLimit\tGas limit required for executing the destination payload payloadLength\tLength of payload to be executed on destination plug Example Request​ Estimating fees for sending a message from Polygon to Optimism https://prod.dlapi.socket.tech/v1/estimate-min-fees?srcPlug=0x7b9ed5C43E87DAFB03211651d4FA41fEa1Eb9b3D&amp;srcChainSlug=2999&amp;dstChainSlug=10&amp;msgGasLimit=100000&amp;payloadLength=100 Note : Add the x-api-key header mentioned above in the request for authentication. Response Parameters​ Parameter\tDescriptionresult\tTotal fees to be paid in the native token of the source chain ","version":"Next","tagName":"h2"},{"title":"Error Messages","type":0,"sectionRef":"#","url":"/dev-resources/errors","content":"Error Messages Error\tSignature\tDescriptionPacketNotProposed()\t0x1c936052\tError emitted when a packet has not been proposed &amp; message is tried for execution InvalidPacketId()\t0xb21147c1\tProposed packetId is invalid InvalidProof()\t0x09bde339\tProof of message inclusion for a given packetId is invalid MessageAlreadyExecuted()\t0x7448c64c\tMessage has already been executed NotExecutor()\t0xc32d1d76\tEmitted when caller of execute method on Socket does not have EXECUTOR_ROLE VerificationFailed()\t0x439cc0cd\tPacket verification failed on Switchboard ErrInSourceValidation()\t0xb39fb5d5\tError emitted when source chainSlug deduced from packetId and msgId don't match LowGasLimit()\t0xd38edae0\tGas Limit set for message execution is not sufficient to cover execution cost SwitchboardExists()\t0x2dff8555\tSwitchboard being registered on Socket already exists InvalidConnection()\t0x63228f29\tSwitchboard passed by Plug during connection does not exist NoPermit(bytes32)\t0x962f6333\tError message thrown when an address does not have permission to execute a function with onlyRole modifier OnlySocket()\t0x503284dc\tError triggered when not called by Socket MsgValueTooLow()\t0x508aaf00\tExecution fees paid to EXECUTOR for message execution on destination chain are insufficient to cover gas fees MsgValueTooHigh()\t0x5dffc92f\tFees set for message delivery on outbound method are too high PayloadTooLarge()\t0x492f620d\tEmitted when payload length is too large InsufficientFees()\t0x8d53e553\tFees set for message delivery on outbound method are insufficient AlreadyAttested()\t0x35d90805\tEmitted when root is already attested by a WATCHER PlugDisconnected()\t0xe741bafb\tError emitted when siblingPlug connection is not found","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"IPlug","type":0,"sectionRef":"#","url":"/dev-resources/Interfaces/IPlug","content":"IPlug // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.8.19; /** * @title IPlug * @notice Interface for a plug contract that executes the message received from a source chain. */ interface IPlug { /** * @dev this should be only executable by socket * @notice executes the message received from source chain * @notice It is expected to have original sender checks in the destination plugs using payload * @param srcChainSlug_ chain slug of source * @param payload_ the data which is needed by plug at inbound call on remote */ function inbound( uint32 srcChainSlug_, bytes calldata payload_ ) external payable; } ","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Fast","type":0,"sectionRef":"#","url":"/dev-resources/MessagingLatency/latency-fast","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Mainnet​","type":1,"pageTitle":"Fast","url":"/dev-resources/MessagingLatency/latency-fast#mainnet","content":"Sending Chain\tLatencyEthereum\t5 mins Polygon\t10 mins Optimism\t3 mins Arbitrum\t3 mins BSC\t3 mins ","version":"Next","tagName":"h3"},{"title":"Testnet​","type":1,"pageTitle":"Fast","url":"/dev-resources/MessagingLatency/latency-fast#testnet","content":"Sending Chain\tLatencyGoerli\t3 mins Mumbai\t3 mins Optimism Testnet\t3 mins Arbitrum Testnet\t3 mins BSC Testnet\t3 mins ","version":"Next","tagName":"h3"},{"title":"Contract Addresses","type":0,"sectionRef":"#","url":"/dev-resources/deployment-addresses","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Socket Address​","type":1,"pageTitle":"Contract Addresses","url":"/dev-resources/deployment-addresses#socket-address","content":"Ethereum Chain Slug : 1 Socket : 0x943AC277...1b9b16f9 Goerli Chain Slug : 5 Socket : 0xf9E6C845...eE884A04 Optimism Chain Slug : 10 Socket : 0x301bD265...E3A1c0a4 BNB Chain Chain Slug : 56 Socket : 0xdF7f95dd...6281C00e Viction testnet Chain Slug : 89 Socket : 0x565810cb...95686339 Polygon Chain Slug : 137 Socket : 0xc20687f8...10DED001 Optimism Goerli Chain Slug : 420 Socket : 0x5054D6c7...803837e1 Stavanger testnet Chain Slug : 647 Socket : 0x834Ee253...D1eE4a86 Lyra testnet Chain Slug : 901 Socket : 0xFDC28fA3...01B212fc Mode testnet Chain Slug : 919 Socket : 0x565810cb...95686339 Lyra Chain Slug : 957 Socket : 0x565810cb...95686339 Parallel Chain Slug : 1024 Socket : 0x565810cb...95686339 Reya Cronos Testnet Chain Slug : 1729 Socket : 0x565810cb...95686339 Aevo Chain Slug : 2999 Socket : 0x565810cb...95686339 Hook Chain Slug : 4665 Socket : 0x565810cb...95686339 Mantle Chain Slug : 5000 Socket : 0x565810cb...95686339 Base Chain Slug : 8453 Socket : 0x12E6e588...D7280156 Mode Chain Slug : 34443 Socket : 0xc317144D...bd14CD61 Arbitrum Chain Slug : 42161 Socket : 0x37cc6745...9355f6Ba Polygon Mumbai testnet Chain Slug : 80001 Socket : 0x54FEAB3E...82717abb Arbitrum Goerli Chain Slug : 421613 Socket : 0x7615Ddf5...4B3031d2 Arbitrum Sepolia Chain Slug : 421614 Socket : 0xEA59E2b1...279aC6F2 Sepolia Chain Slug : 11155111 Socket : 0x07e11D1A...D51ae237 Aevo testnet Chain Slug : 11155112 Socket : 0xcE713890...89844A13 Optimism Sepolia Chain Slug : 11155420 Socket : 0xEA59E2b1...279aC6F2 Ancient8 testnet2 Chain Slug : 28122024 Socket : 0x565810cb...95686339 Hook testnet Chain Slug : 46658378 Socket : 0x565810cb...95686339 SX Network Testnet Chain Slug : 686669576 Socket : 0x834Ee253...D1eE4a86 XAI Testnet Chain Slug : 1399904803 Socket : 0xf7018072...5aF3275A Chain Slug : 2863311531 Socket : 0x565810cb...95686339  ","version":"Next","tagName":"h3"},{"title":"Socket Switchboards​","type":1,"pageTitle":"Contract Addresses","url":"/dev-resources/deployment-addresses#socket-switchboards","content":"FAST is the standard integration type, choose FAST unless you're building a custom usecase Local : EthereumGoerliOptimismBNB ChainViction testnetPolygonOptimism GoerliStavanger testnetLyra testnetMode testnetLyraParallelReya Cronos TestnetAevoHookMantleBaseModeArbitrumPolygon Mumbai testnetArbitrum GoerliArbitrum SepoliaSepoliaAevo testnetOptimism SepoliaAncient8 testnet2Hook testnetSX Network TestnetXAI Testnet Sibling : EthereumGoerliBNB ChainViction testnetPolygonOptimism GoerliStavanger testnetLyra testnetMode testnetLyraParallelReya Cronos TestnetAevoHookMantleBaseModeArbitrumPolygon Mumbai testnetArbitrum GoerliArbitrum SepoliaSepoliaAevo testnetOptimism SepoliaAncient8 testnet2Hook testnetSX Network TestnetXAI Testnet Type : FASTOPTIMISTICNATIVE_BRIDGE LocalSlug\tSiblingSlug\tType\tSwitchboard Address10\t10\tFAST\tNot Supported ","version":"Next","tagName":"h3"},{"title":"ISocket","type":0,"sectionRef":"#","url":"/dev-resources/Interfaces/ISocket","content":"ISocket Required by Plugs for the following : Connect to Socket Sending outbound messages Calculating message delivery fees on-chain // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.8.19; import &quot;./ITransmitManager.sol&quot;; import &quot;./IExecutionManager.sol&quot;; /** * @title ISocket * @notice An interface for a cross-chain communication contract * @dev This interface provides methods for transmitting and executing messages between chains, * connecting a plug to a remote chain and setting up switchboards for the message transmission * This interface also emits events for important operations such as message transmission, execution status, * and plug connection */ interface ISocket { /** * @notice A struct containing fees required for message transmission and execution * @param transmissionFees fees needed for transmission * @param switchboardFees fees needed by switchboard * @param executionFee fees needed for execution */ struct Fees { uint128 transmissionFees; uint128 executionFee; uint128 switchboardFees; } /** * @title MessageDetails * @dev This struct defines the details of a message to be executed in a Decapacitor contract. */ struct MessageDetails { // A unique identifier for the message. bytes32 msgId; // The fee to be paid for executing the message. uint256 executionFee; // The min amount of gas that can be used to execute the message. uint256 minMsgGasLimit; // The extra params which might provide msg value and additional info needed for message exec bytes32 executionParams; // The payload data to be executed in the message. bytes payload; } /** * @title ExecutionDetails * @dev This struct defines the execution details */ struct ExecutionDetails { // packet id bytes32 packetId; // proposal count uint256 proposalCount; // gas limit needed to execute inbound uint256 executionGasLimit; // proof data required by the Decapacitor contract to verify the message's authenticity bytes decapacitorProof; // signature of executor bytes signature; } /** * @notice emits the status of message after inbound call * @param msgId msg id which is executed */ event ExecutionSuccess(bytes32 msgId); /** * @notice emits the config set by a plug for a remoteChainSlug * @param plug address of plug on current chain * @param siblingChainSlug sibling chain slug * @param siblingPlug address of plug on sibling chain * @param inboundSwitchboard inbound switchboard (select from registered options) * @param outboundSwitchboard outbound switchboard (select from registered options) * @param capacitor capacitor selected based on outbound switchboard * @param decapacitor decapacitor selected based on inbound switchboard */ event PlugConnected( address plug, uint32 siblingChainSlug, address siblingPlug, address inboundSwitchboard, address outboundSwitchboard, address capacitor, address decapacitor ); /** * @notice registers a message * @dev Packs the message and includes it in a packet with capacitor * @param remoteChainSlug_ the remote chain slug * @param minMsgGasLimit_ the gas limit needed to execute the payload on remote * @param payload_ the data which is needed by plug at inbound call on remote */ function outbound( uint32 remoteChainSlug_, uint256 minMsgGasLimit_, bytes32 executionParams_, bytes32 transmissionParams_, bytes calldata payload_ ) external payable returns (bytes32 msgId); /** * @notice executes a message * @param executionDetails_ the packet details, proof and signature needed for message execution * @param messageDetails_ the message details */ function execute( ISocket.ExecutionDetails calldata executionDetails_, ISocket.MessageDetails calldata messageDetails_ ) external payable; /** * @notice seals data in capacitor for specific batchSize * @param batchSize_ size of batch to be sealed * @param capacitorAddress_ address of capacitor * @param signature_ signed Data needed for verification */ function seal( uint256 batchSize_, address capacitorAddress_, bytes calldata signature_ ) external payable; /** * @notice proposes a packet * @param packetId_ packet id * @param root_ root data * @param switchboard_ The address of switchboard for which this packet is proposed * @param signature_ signed Data needed for verification */ function proposeForSwitchboard( bytes32 packetId_, bytes32 root_, address switchboard_, bytes calldata signature_ ) external payable; /** * @notice sets the config specific to the plug * @param siblingChainSlug_ the sibling chain slug * @param siblingPlug_ address of plug present at sibling chain to call inbound * @param inboundSwitchboard_ the address of switchboard to use for receiving messages * @param outboundSwitchboard_ the address of switchboard to use for sending messages */ function connect( uint32 siblingChainSlug_, address siblingPlug_, address inboundSwitchboard_, address outboundSwitchboard_ ) external; /** * @notice deploy capacitor and decapacitor for a switchboard with a specified max packet length, sibling chain slug, and capacitor type. * @param siblingChainSlug_ The slug of the sibling chain that the switchboard is registered with. * @param maxPacketLength_ The maximum length of a packet allowed by the switchboard. * @param capacitorType_ The type of capacitor that the switchboard uses. * @param siblingSwitchboard_ The switchboard address deployed on `siblingChainSlug_` */ function registerSwitchboardForSibling( uint32 siblingChainSlug_, uint256 maxPacketLength_, uint256 capacitorType_, address siblingSwitchboard_ ) external returns (address capacitor, address decapacitor); /** * @notice Emits the sibling switchboard for given `siblingChainSlug_`. * @dev This function is expected to be only called by switchboard. * @dev the event emitted is tracked by transmitters to decide which switchboard a packet should be proposed on * @param siblingChainSlug_ The slug of the sibling chain * @param siblingSwitchboard_ The switchboard address deployed on `siblingChainSlug_` */ function useSiblingSwitchboard( uint32 siblingChainSlug_, address siblingSwitchboard_ ) external; /** * @notice Retrieves the packet id roots for a specified packet id. * @param packetId_ The packet id for which to retrieve the root. * @param proposalCount_ The proposal id for packetId_ for which to retrieve the root. * @param switchboard_ The address of switchboard for which this packet is proposed * @return The packet id roots for the specified packet id. */ function packetIdRoots( bytes32 packetId_, uint256 proposalCount_, address switchboard_ ) external view returns (bytes32); /** * @notice Retrieves the minimum fees required for a message with a specified gas limit and destination chain. * @param minMsgGasLimit_ The gas limit of the message. * @param remoteChainSlug_ The slug of the destination chain for the message. * @param plug_ The address of the plug through which the message is sent. * @return totalFees The minimum fees required for the specified message. */ function getMinFees( uint256 minMsgGasLimit_, uint256 payloadSize_, bytes32 executionParams_, bytes32 transmissionParams_, uint32 remoteChainSlug_, address plug_ ) external view returns (uint256 totalFees); /// return instance of transmit manager function transmitManager__() external view returns (ITransmitManager); /// return instance of execution manager function executionManager__() external view returns (IExecutionManager); } ","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"ISwitchboard","type":0,"sectionRef":"#","url":"/dev-resources/Interfaces/ISwitchboard","content":"ISwitchboard Switchboards are required to have this interface to interact with Socket // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.8.19; /** * @title ISwitchboard * @dev The interface for a switchboard contract that is responsible for verification of packets between * different blockchain networks. */ interface ISwitchboard { /** * @notice Registers itself in Socket for given `siblingChainSlug_`. * @dev This function is expected to be only called by admin as it handles the capacitor config for given chain * @param siblingChainSlug_ The slug of the sibling chain to register switchboard with. * @param maxPacketLength_ The maximum length of a packet allowed by the switchboard. * @param capacitorType_ The type of capacitor that the switchboard uses. * @param initialPacketCount_ The packet count at the time of registering switchboard. Packets with packet count below this won't be allowed * @param siblingSwitchboard_ The switchboard address deployed on `siblingChainSlug_` */ function registerSiblingSlug( uint32 siblingChainSlug_, uint256 maxPacketLength_, uint256 capacitorType_, uint256 initialPacketCount_, address siblingSwitchboard_ ) external; /** * @notice Updates the sibling switchboard for given `siblingChainSlug_`. * @dev This function is expected to be only called by admin * @param siblingChainSlug_ The slug of the sibling chain to register switchboard with. * @param siblingSwitchboard_ The switchboard address deployed on `siblingChainSlug_` */ function updateSibling( uint32 siblingChainSlug_, address siblingSwitchboard_ ) external; /** * @notice Checks if a packet can be allowed to go through the switchboard. * @param root the packet root. * @param packetId The unique identifier for the packet. * @param proposalCount The unique identifier for a proposal for the packet. * @param srcChainSlug The unique identifier for the source chain of the packet. * @param proposeTime The time when the packet was proposed. * @return A boolean indicating whether the packet is allowed to go through the switchboard or not. */ function allowPacket( bytes32 root, bytes32 packetId, uint256 proposalCount, uint32 srcChainSlug, uint256 proposeTime ) external view returns (bool); /** * @notice Retrieves the minimum fees required for the destination chain to process the packet. * @param dstChainSlug the unique identifier for the destination chain of the packet. * @return switchboardFee the switchboard fee required for the destination chain to process the packet. * @return verificationOverheadFees the verification fee required for the destination chain to process the packet. */ function getMinFees( uint32 dstChainSlug ) external view returns (uint128 switchboardFee, uint128 verificationOverheadFees); /** * @notice Receives the fees for processing of packet. * @param siblingChainSlug_ the chain slug of the sibling chain. */ function receiveFees(uint32 siblingChainSlug_) external payable; /** * @notice Sets the minimum fees required for the destination chain to process the packet. * @param nonce_ the nonce of fee Updater to avoid replay. * @param dstChainSlug_ the unique identifier for the destination chain. * @param switchboardFees_ the switchboard fee required for the destination chain to process the packet. * @param verificationOverheadFees_ the verification fee required for the destination chain to process the packet. * @param signature_ the signature of the request. * @dev not important to override in all switchboards */ function setFees( uint256 nonce_, uint32 dstChainSlug_, uint128 switchboardFees_, uint128 verificationOverheadFees_, bytes calldata signature_ ) external; } ","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Native","type":0,"sectionRef":"#","url":"/dev-resources/MessagingLatency/latency-native","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Mainnet​","type":1,"pageTitle":"Native","url":"/dev-resources/MessagingLatency/latency-native#mainnet","content":"Path\tL1 -&gt; L2\tL2 -&gt; L1Polygon\t35 mins\t3 hours Optimism\t30 mins - 3 hours\t7 days Arbitrum\t30 mins - 3 hours\t7 days ","version":"Next","tagName":"h3"},{"title":"Testnet​","type":1,"pageTitle":"Native","url":"/dev-resources/MessagingLatency/latency-native#testnet","content":"Path\tL1 -&gt; L2\tL2 -&gt; L1Mumbai\t30 mins\t3 hours Optimism Testnet\t30 mins - 3 hours\t7 days Arbitrum Testnet\t30 mins - 3 hours\t7 days ","version":"Next","tagName":"h3"},{"title":"Optimistic","type":0,"sectionRef":"#","url":"/dev-resources/MessagingLatency/latency-optimistic","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Mainnet​","type":1,"pageTitle":"Optimistic","url":"/dev-resources/MessagingLatency/latency-optimistic#mainnet","content":"Sending Chain\tLatencyEthereum\t2 hours Polygon\t2 hours Optimism\t2 hours Arbitrum\t2 hours BSC\t2 hours ","version":"Next","tagName":"h3"},{"title":"Testnet​","type":1,"pageTitle":"Optimistic","url":"/dev-resources/MessagingLatency/latency-optimistic#testnet","content":"Sending Chain\tLatencyGoerli\t2 hours Mumbai\t2 hours Optimism Testnet\t2 hours Arbitrum Testnet\t2 hours BSC Testnet\t2 hours ","version":"Next","tagName":"h3"},{"title":"Counter Tutorial","type":0,"sectionRef":"#","url":"/dev-resources/TutorialSection/example-counter","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Code Walkthrough​","type":1,"pageTitle":"Counter Tutorial","url":"/dev-resources/TutorialSection/example-counter#code-walkthrough","content":"You can find the code for this tutorial in the SocketDL-examples GitHub repo. This example inherits the PlugBase contract, which is a boilerplate contract with key functions {WIP: Link it} needed to interact with Socket. Plugs may use PlugBase to abstract these functions, or directly define them in their contract. The Cross-chain Counter has 2 key functions : setRemoteNumber setRemoteNumber takes newNumber and toChainSlug parameters. This function calls outbound method on Socket which initiates the cross-chain message to update the counter value on the destination chain /* newNumber_ is the value the counter will be set to toChainSlug_ is the chain ID of the destination chain */ function setRemoteNumber( uint256 newNumber_, uint256 toChainSlug_ ) external payable { _outbound(toChainSlug_, destGasLimit, msg.value, abi.encode(newNumber_)); } _receiveInbound Socket calls the inbound function on PlugBase when relaying messages on destination chain. inbound calls the _receiveInbound method which decodes the number from the payload and sets the local chain counter value to the number received in the message. More on this in message receiving lifecycle. function inbound( uint256 siblingChainSlug_, bytes calldata payload_ ) external payable { require(msg.sender == address(socket), &quot;no auth&quot;); _receiveInbound(siblingChainSlug_, payload_); } function _receiveInbound( uint256, bytes memory payload_ ) internal virtual override { uint256 newNumber = abi.decode(payload_, (uint256)); setNumber(newNumber); }  ","version":"Next","tagName":"h3"},{"title":"Setup​","type":1,"pageTitle":"Counter Tutorial","url":"/dev-resources/TutorialSection/example-counter#setup","content":"Local Environment (Foundry)​ Clone the GitHub repo and run forge installTo compile and deploy the Counter example, run the following command forge create --rpc-url &lt;RPC&gt; \\ --constructor-args &lt;SOCKET_CONTRACT_ADDRESS&gt; \\ --private-key &lt;PRIVATE_KEY&gt; \\ src/impl/Counter.sol:Counter  Remix​ The counter example can be loaded onto Remix from here Constructor Arguments​ The counter example takes Socket address as an argument, which can be found in deployments This example can be deployed on any supported testnets or mainnets. In this tutorial, we'll be deploying the Counters on the following two chains, Polygon and Optimism : Chain\tSocket address137\t0x4c8D9ab0F4f6A959092248982bd58D2C964957d6 10\t0x2959eBC446A4dFB30b04AfD62B0cBD3F914306B4 ","version":"Next","tagName":"h3"},{"title":"Configuring Plugs​","type":1,"pageTitle":"Counter Tutorial","url":"/dev-resources/TutorialSection/example-counter#configuring-plugs","content":"As described in the Getting Started section, Plugs must connect to Socket before they can send/receive messages between one another. After deploying the Counter contract on Polygon and Optimism, we need to initiate a connect() transaction on respective chains. The script for making this transaction can be found here. This step calls the connect method on Socket with the following parameters. {WIP: Link it} For Polygon, the values are : Parameter\tValuesiblingChainSlug\t10 siblingPlug\tAddress of Counter on Optimism inboundSwitchboard\t0x2521b29FD8d3787Ab42141f55F6b462E6115C737 outboundSwitchboard\t0x2521b29FD8d3787Ab42141f55F6b462E6115C737 For Optimism, the values are : Parameter\tValuesiblingChainSlug\t137 siblingPlug\tAddress of Counter on Polygon inboundSwitchboard\t0x8654cB74011C9972dd63Ed691d310e1BAA85Fe9E outboundSwitchboard\t0x8654cB74011C9972dd63Ed691d310e1BAA85Fe9E This connection is required on each respective chain a Plug receives/sends messages between. Once the connection step is complete, you can verify the connection was successful by calling the getPlugConfig method on Socket. This is a view function that returns the config of the plug. ","version":"Next","tagName":"h3"},{"title":"Setting Counter value on remote chain​","type":1,"pageTitle":"Counter Tutorial","url":"/dev-resources/TutorialSection/example-counter#setting-counter-value-on-remote-chain","content":"For this tutorial, we'll be setting Counter value on Polygon to 55 from Optimism. To do this, we call the setRemoteNumber() function on our Counter deployed on Polygon. The script for making this transaction can be found here. // Script will be here as well The parameter values when calling this function on Optimism are : Parameter\tValuenewNumber_\t55 toChainSlug_\t137 This sends a message payload from Optimism to Polygon with the number 55 encoded in payload. This number is decoded from the payload on the destination Counter and set as the new Counter value. ","version":"Next","tagName":"h3"},{"title":"Tracking status of message​","type":1,"pageTitle":"Counter Tutorial","url":"/dev-resources/TutorialSection/example-counter#tracking-status-of-message","content":"To track the status of any outbound message can be tracked with the status API. Learn more in the Status API {WIP : link it} ","version":"Next","tagName":"h3"},{"title":"Message delivery to set Counter value​","type":1,"pageTitle":"Counter Tutorial","url":"/dev-resources/TutorialSection/example-counter#message-delivery-to-set-counter-value","content":"Once the packet is verified, Socket sends the message payload to the remote Counter on Polygon. It calls the inbound function on the remote Counter, which decodes the newNumber from the payload and sets it on the local chain. Find a detailed explanation of this in the Receiving message lifecycle. The value of Counter on Polygon can be checked using this script // Add script to check the new counter value Once the payload is sent to the remote Counter, message execution is marked complete. You're Plugged! You've successfully built and deployed a Plug! Explore more examples &amp; participate in Surge! ","version":"Next","tagName":"h3"},{"title":"Message Failure & Retry","type":0,"sectionRef":"#","url":"/dev-resources/TutorialSection/retry-execute","content":"Message Failure &amp; Retry Message execution may fail on the destination chain for the following reasons : gasLimit required for message execution on the destination chain execeeds the msgGasLimit set for message delivery on source PlugFees sent on source chain do not cover the message execution fees on destination chainThe inbound call on the Plug is failing, which may happen if there's some logic in the inbound method that's failing.The packet which includes the message is not verified yet Executors simulate the message execution transaction and check for its success. If it's successful, they execute the message on-chain. Else, they keep trying to simulate the transaction for 2-3 hours, after which they stop. Currently, the message is untended and would have to be sent again from the source chain. In the first and second case as well, Plugs cannot make a fallback action to execute the message. The message would have to be sent again from the source chain.","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"What is SocketDL?","type":0,"sectionRef":"#","url":"/introduction","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Features of Socket DL​","type":1,"pageTitle":"What is SocketDL?","url":"/introduction#features-of-socket-dl","content":"Arbitrary Message Passing : Arbitrary Message Passing allows a contract on Chain A to send a message (bytes encoded) to a contract on Chain B. This allows contracts on different chains to read and write to each other's state.Modular Architecture : SocketDL has a modular architecture which allows dApps to choose parts of the Socket stack they'd like to use. For instance, dApps can use Socket for message verification and validation, but can build their own off-chain agents for message delivery and execution.Security w/ Configurability : Socket allows Plugs to configure Switchboards used for message passing w/ other plugs. dApps can configure different levels of security using switchboards. For example, using native bridge for critical messaging, but n/n validator consensus for faster relatively less secure communication.Easy spec to build : Smart contracts simply need to inherit PlugBase and support a simple interface to add cross-chain capabilities to its functions Learn more about SocketDL architecture, message lifecycle &amp; components. ","version":"Next","tagName":"h3"},{"title":"Use Cases​","type":1,"pageTitle":"What is SocketDL?","url":"/introduction#use-cases","content":"App Chain Tokens ERC-20 that can be bridged b/w chains through a Lock-n-Mint or Burn-n-Mint mechanism, secured by SocketDL. They don't require protocols to bootstrap liquidity for the token across chains. Live in production powering USDC bridging on Aevo's Optimistic App-Chain. Learn more here. DeFi Composability Cross-chain lending and borrowingMulti-chain Yield aggregatorsCross-chain Deposits (Zaps) Gaming and NFTs Chain agnostic NFTs that can be bridged/minted between chains. This also enables unique usecases for on-chain gaming New usecases Chain Abstracted Wallets, Governance, Data Availability, &amp; much more! ","version":"Next","tagName":"h3"},{"title":"What's Next​","type":1,"pageTitle":"What is SocketDL?","url":"/introduction#whats-next","content":"Send &amp; Receive Messages   Learn SocketDL  ","version":"Next","tagName":"h3"},{"title":"Plugs","type":0,"sectionRef":"#","url":"/Learn/Components/Plugs","content":"Plugs Smart contracts that connect to Socket to send messages to each other across chains are called Plugs. Before your Plugs can communicate to each other directly, you need to connect to Socket and inform Socket about your sibling Plugs. Plugs must “connect” or get “plugged into” Socket for each unique sibling network for sending/receiving messages. It's recommended to keep this action permissioned, malicious configuration while connecting to Socket will cause unintended actions. In case a connection between two plugs already exists on a chain, re-connecting will override the previous configuration, Socket by default doesn't block this behaviour. However you are free to block this behaviour from your Plug.","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Capacitors","type":0,"sectionRef":"#","url":"/Learn/Components/Capacitors","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"CapacitorFactory​","type":1,"pageTitle":"Capacitors","url":"/Learn/Components/Capacitors#capacitorfactory","content":"CapacitorFactory is an upgradable contract that lists different kinds of Capacitors available. Note that this component being upgradable has no impact on message security, your capacitor once selected is embedded into the switchboard. CapacitorFactory being upgradable will have no effect on already deployed capacitors and configuration. The factory is like a capacitor menu item. CapacitorFactory assigns each type of Capacitor a &quot;type&quot; which is a unique identifier(uint32) used to refer to a specific capacitor. While registering a switchboard to Socket like defined here, you specify a capacitor_type, the registration function deploys the switchboard specific capacitor and decapacitor. Developers have the ability to define the level of batching they want while they register the switchboard. More details around access control and ownership of CapacitorFactory contract here. ","version":"Next","tagName":"h2"},{"title":"Fees","type":0,"sectionRef":"#","url":"/Learn/Concepts/fees","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Estimating Fees​","type":1,"pageTitle":"Fees","url":"/Learn/Concepts/fees#estimating-fees","content":"Fees can be estimated off-chain using the Fee Estimation API. The API calculates the total fee to be sent while sending a message and also returns a breakdown of each fee component. ","version":"Next","tagName":"h3"},{"title":"Estimating Fees on-chain​","type":1,"pageTitle":"Fees","url":"/Learn/Concepts/fees#estimating-fees-on-chain","content":"Sending a cross-chain message requires the message to be verified and executed on the destination chain and the fees for this need to be calculated with the destination chain gasPrice. But the gasPrice of the destination chain is not known on the source chain. To enable this calculation, Socket maintains a siblingChain gas fee mapping on the ExecutionManager, TransmitManager and Switchboards. These fees are updated periodically by off-chain agents with the FEES_UPDATER_ROLE How to fetch fee estimate​ Plugs can use ISocket to call getMinFees method on Socket. This method takes the payload execution gasLimit, destination chain ID, payload size and plug address as input and calculates the total fee. This enables Plugs to be completely on-chain and not rely on any off-chain services for fee calculation or to interact with Socket. getMinFees returns the totalFee, which is to be sent in the native token of the chain when calling outbound on Socket. ","version":"Next","tagName":"h3"},{"title":"Minimum Fees​","type":1,"pageTitle":"Fees","url":"/Learn/Concepts/fees#minimum-fees","content":"Socket calculates the minimum fee to ensure the delivery and execution of the message. Plugs can pay a premium on this fee to ensure their message always gets included. This is relevant particularly in case of gasPrice hikes on the destination chain. ","version":"Next","tagName":"h3"},{"title":"Fee Collection​","type":1,"pageTitle":"Fees","url":"/Learn/Concepts/fees#fee-collection","content":"Fees are collected in their respective contracts for each type of fee. These fees are later withdrawn by off-chain actors (Transmitters, Watchers, Executors). ","version":"Next","tagName":"h3"},{"title":"Packet","type":0,"sectionRef":"#","url":"/Learn/Components/Packet","content":"Packet Packet is a cryptographic representation of PackedMessages. Capacitor produces Packets as soon as PackedMessages are added to it. PackedMessages created whenever a new message is sent via the Outbound method and are compressed representation of the following: chainSlug: ChainSlug of the local networkmsg.sender: Src Plug for the chainSlugSiblingChainSlug: ChainSlug for the sibling networkSiblingPlug: Address for the sibling Plug on RemoteChainSlugMessageDetails: Details about a message such as msgId, minMsgGasLimit, executionParams, payload and executionFeemsgId : Unique identifier for a messageminMsgGasLimit: Minimum gasLimit provided by the Plug for message execution on destinationExecutionFee: Execution fee provided by the PlugPayload: Message provided by the Plug to be relayed to destinationexecutionParams: Additional execution details bytes32 packedMessage = hasher__.packMessage( chainSlug, msg.sender, siblingChainSlug_, plugConfig.siblingPlug, messageDetails ); SealedPacket = Seal(Packet(PackMessage(MSG_DETAILS))) ","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"TransmitManager","type":0,"sectionRef":"#","url":"/Learn/Components/TransmitManager","content":"TransmitManager As messages get accumulated by the capacitor, transmitters can seal the capacitors whenever it's ready to discharge to seal the Packet and create SealedPacket. Once the packet is sealed it's ready to be transmitted and submitted to the propose method on the destination Socket. To seal and to propose the msg.sender needs to have the transmitter's signature over the Packet. Transmitters are part of the delivery layer and are responsible for only the liveliness of the protocol. Transmitters operations are completely on-chain and publicly visible to everyone, this is a very important property. Transmitters are also very light-weight and can be extended to any chain quickly. Transmitters are managed by TransmitManager contract which takes care of the following: Leader selection between multiple transmitters Fee collection and distributionManaging the set of transmitters","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Switchboards","type":0,"sectionRef":"#","url":"/Learn/Components/Switchboards","content":"Switchboards Plugs connect to Socket via Switchboards(just like in real life). Switchboards are like open-source permissionless configuration bundles that plugs can opt into OR build their own configuration bundles. Switchboards contain the following things: Packet authentication via allowPacket methodCapacitor to be used for that switchboardDecapacitor to be used for verifying message inclusion in PacketminFees for packet validation Switchboards allow developers to permissionlessly authenticate Packets before they get executed on their Plugs, we think there are various authentication models that people can leverage to manage tradeoffs for their applications. Anyone can build a switchboard that satisfies the ISwitchboard interface. It needs to be registered to Socket before Plugs can use it via the registerSwitchboard() method on Socket. Registering a Switchboard is completely permissionless. Socket Labs has bootstrapped some switchboards with different tradeoffs for end developers, we encourage developers to feel free to leverage these switchboards if they are suitable for their usecase. Optimistic Switchboard: Allow 1/N trust-minimised and cheap validation by introducing a challenge mechanism pre-execution where N parties can stop the packet from getting executed. This Switchboard will be extremely cheap to leverage but will have a latency of the challenge period. Fast Switchboard: Allow 1/N trust minimised validation by having all N parties attest on-chain, this is still as secure as the OptimisticSwitchboard but might cost more on-chain depending on the destination chain.Native Switchboard: Allows developers to leverage native verification for eg: rollup-validation wherever it's available, we have built these connectors for Polygon, Arbitrum and Optimism right now. Developers who want to leverage security of the native-security should leverage these. We encourage developers to build their own Switchboards and register them on the Socket contract, we would love to drive innovation on the verification layer.","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Tracking Messages & Packets","type":0,"sectionRef":"#","url":"/Learn/Concepts/learn-tracking","content":"Tracking Messages &amp; Packets When plugs send a message, a MessageOutbound event is emitted with a msgId, which is a unique identifier for each message. This is generated by performing bitwise operations on the local chain ID and message count The status of a message can be tracked using an API built by Socket. More on this in Status Tracking API Socket transmits packets from one chain to another. Messages need to get included into these packets to be delivered to the destination chain. Packets are also assigned a unique identifier packetId, generated from the local chain ID, capacitor address and packet count on given capacitor. Once a message is sent outbound, it will be included in a packet. Packets are periodically sealed by Transmitters and then proposed on the destination chain. Upon sealing, a PacketVerifiedAndSealed event is emitted. This has the packetId and can be used to track the status of the packet a message is included in.","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Off-Chain Agents","type":0,"sectionRef":"#","url":"/Learn/OffChain-Agents","content":"Off-Chain Agents There are a couple of off-chain agents running at all times to process cross-chain messages, this section will outline some of those. The only 2 cross-chain agents that are part of Socket Protocol are the following: Transmitters: Transmitters are the agents that are responsible for sealing packets on the source chain to finalise them and propose them on the destination chain. They are only responsible for liveliness of the system, the protocol design makes sure they can't censor packets as sealing can only be done sequentially and once a packet is sealed anyone can propose the sealed packet on the destination chain.Executors: Executors are workers that execute the messages from the Packet on the destination chain by calling the inbound function on the Plugs. Apart from the above there are no native off-chain agents to Socket protocol. Depending on the switchboard you leverage there may or may not be an off-chain agent involved there.","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Ownership","type":0,"sectionRef":"#","url":"/Learn/Ownership","content":"Ownership We strongly believe that contracts should be immutable, non-upgradable, upgrades should be opt-in by clients. We have clear roles on the contract and plans on how to remove them. All roles are listed in the AccessRoles.sol contract Here are some of the roles and the purpose: RESCUE_ROLE: It's only used to rescue funds if stuck in a contract which isnt supposed to hold funds. This is just a safety role to allow us to give back people their ERC20s or ETHER that they might have accidentally sent.WITHDRAW_ROLE: We haven't built a permissionless way to execute fee distribution via TransmitManager, ExecutionManager and Switchboard yet, hence we have this special role to allow us to withdraw and distribute the fees. This role will deprecate once the fee distribution logic is on-chain. This does not impact the security implications for the end user and only affects the off-chain agents.EXECUTOR_ROLE: This role whitelists addresses to allow them to execute messages post permissionless validation by the switchboard. This role is currently permissioned to prevent users from harmful effects of REV. This role holds no security implications.TRANSMITTER_ROLE: This role is not part of Socket protocol. This role is used by TransmitManager to grant approval to a particular transmitter to seal and propose packets. TransmitterManager is a modular contract. GOVERNANCE_ROLE: This one is an interesting one. The role is minimally used by intention. This role CANNOT UPDATE the security properties of a message and or modify user preferences. This role is minimally used in the core-contracts to update the TransmitManager and ExecutionManager modules, both of which cannot harm the end developer and in the worst case just pause the protocol as the current TransmitManager and ExecutionManager modules are implemented. Apart from the core-contracts, the GOVERNANCE_ROLE can be utilised with a different setting in the switchboards but switchboards are permissionless already and developers can remove or update the usage of the role according to their preferences.TRIP_ROLE: This role allows holder to trip or pause a Switchboard, in case of smart contract bugs on a specific SwitchboardUN_TRIP_ROLE: This role allows holder to untrip or unpause a SwitchboardWATCHER_ROLE: Role assigned to Switchboard watchers. Watchers play different a different role depending on the Switchboard used. For example, in Optimistic Switchboards, Watchers can trip a specific path/packet if any fraud was detected.FEES_UPDATER_ROLE: Role assigned to off-chain agents that update gas fees for each siblingChain on a given switchboard, TransmitManager and ExecutionManager","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Glossary","type":0,"sectionRef":"#","url":"/Learn/glossary","content":"Glossary We have introduced a lot of new terms and that is by design. We think for something as critical as AMB's nothing should be assumed or taken for-granted. We think these new terms are accurate and will encourage people to look into the docs/code and discourage assumptions. Here is a quick run-down of some of the terms that you will come across the entire documentation: Socket: Socket is the core contract deployed on all networks that are supported. All core modules and functions exist within SocketPlug/Plugs: Plugs are smart contract applications that connect with Socket to send and receive cross-chain messages via the IPlug interface. Plugs are generally adapter contracts that connect your main Smart contract to the messaging infrastructure.Message: Message is the payload you want to transmit along with relevant meta-data like destination chainSlug etc. Packet: Packets are a collection of messages sent from one chain to another. The validity of messages in a packet is verified on the destination chain based on the logic prescribed in the configured switchboard. Read more.Sealed Packet: As soon as the transmitter seals the packet on the source-chain with their signature it's called &quot;SealedPacket&quot;. Read more about how transmitters work here. Capacitor: Capacitor is responsible for storing messages in the form of a Packet. The packet is released when the transmitter calls the sealPacket method on the capacitor. Capacitors allow for native batching of payloads for better gas-performance. Read more.Switchboard: Switchboards are the authentication/verification modules that allow developers to have custom verification for their payloads/messages. They can be permissionlessly built and deployed by the community. Read moreTransmitter: Transmitters are the entities responsible for transmission of Packet across layers, their activity is completely on-chain and managed by TransmitManager. Read moreChainSlug: ChainSlug is a unique identifier for a particular network or Socket deployment. It's different than Chain ID or Network ID used on EVM networks. You can find the assigned ChainSlugs in the deployments section","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Protocol Design","type":0,"sectionRef":"#","url":"/Learn/protocol-design","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Protocol Design","url":"/Learn/protocol-design#introduction","content":"Socket is an on-chain contract that transmits payloads between chains. When a payload is sent by a contract to Socket deployed locally on that chain, Socket compresses it into a Packet - a cryptographic hash representing 1000s of payloads that want to be sent to another chain. Packet delivery is carried out by off-chain participants called &quot;Transmitters&quot;. Much like a sequencer in an L2, the transmitter is responsible for delivering a bunch of payloads from one-chain to another. However, an important difference is, Transmitter first signs and seals a packet on the source side and then submits the packet on the destination side. The packet, along with the transmitter’s signature, is now available on Socket on both chains On the destination chain, contracts called Switchboards allow protocols to select context around how &amp; when a delivered payload should be processed. Socket appoints executors to process the message payload only if it meets conditions on the protocol selected Switchboard. For example, accept payload after timeout of 2 hours, accept payload if native bridge confirms etc. There are several components in the Socket protocol that work together to make the above happen.  ","version":"Next","tagName":"h2"},{"title":"Architecture​","type":1,"pageTitle":"Protocol Design","url":"/Learn/protocol-design#architecture","content":"Socket is built in a modular fashion with various layers with defined APIs/Interfaces between them which allows developers the ability to leverage the software-stack in different and more efficient ways depending on their application context. The protocol consists of four key layers: Application Layer: This layer consists of Plugs, which are smart contract applications built to interact with Socket. Plugs follow a specified API and communicate through deployed Socket instances between any two supported chains. The core Socket contract functions as an on-chain endpoint that sends and receives payloads between chains. As applications send payloads through Plugs, Socket compresses them into cryptographic hashes called Packets, which represent thousands of payloads across apps.Delivery Layer: The delivery layer handles message batching and packet delivery between chains. Capacitor contracts in Socket store packets until they are ready to be sealed. Transmitters, off-chain actors deliver packets between chains by committing with their signatures on both source and destination chains. This ensures transparency and accountability. The verification layer can use this to build trustless verification schemes. Permissionless and transparent message delivery allows for an efficient marketplace for message delivery.Verification Layer: The layer for packet and message verification through Switchboards. These customizable verification modules allow developers to define custom conditions for packet acceptance or rejection, offering flexibility in terms of security and performance. On the destination chain, contracts called Switchboards enable apps to choose the context in which a delivered payload is processed. Socket processes the payload only if it meets the conditions specified by the app-selected Switchboard, such as accepting payloads after a 2-hour timeout or confirming payloads through a native rollup bridge. Permissionlessness and modularity at the verification layer is a core advantage and design principle for Socket. Execution Layer: This layer handles message execution on the destination chain after verification, allowing third-party relayers like Gelato to handle execution, or for applications or users to execute their own messages with various re-try mechanisms etc.  Learn more about individual components in Components and Offchain Agents. ","version":"Next","tagName":"h2"},{"title":"Lifecycle","type":0,"sectionRef":"#","url":"/Learn/lifecycle","content":"","keywords":"messaging  datalayer  socket  socket.tech  DL  interoperability  Bungee  SocketDL  SocketSurge  Surge","version":"Next"},{"title":"Connecting to Socket​","type":1,"pageTitle":"Lifecycle","url":"/Learn/lifecycle#connecting-to-socket","content":" Before Plugs can start sending and receiving messages, they need to connect or get &quot;plugged&quot; into Socket. Plugs connect to sibling plugs deployed on other chains by sending configuration details such as sibling chain ID, sibling plug address and switchboard configuration. Upon connection, Socket generates a unique identifier for the configuration and stores it. It then emits an event PlugConnected with the config data. Here's an example transaction. General Notes :​ Plugs may use different switchboards depending on their usecases and security requirements. They can even build a custom switchboard.Plugs can only connect to one plug on each sibling chain. Connecting with a different sibling plug configuration for the same chain will override the previous configuration. ","version":"Next","tagName":"h3"},{"title":"Sending a message​","type":1,"pageTitle":"Lifecycle","url":"/Learn/lifecycle#sending-a-message","content":"Plugs build on top of Socket to initiate state changes on Plugs deployed on other chains. They do this by passing a message payload that has the state changes encoded, which destination plugs decode and execute.  To pass a message, Plugs call the outbound method on Socket with fees, siblingChainSlug, msgGasLimit, payload, transmitterParams, executorParams. Socket checks the stored configuration of the plug and verifies a connection with the sibling chain was previously instantiated. It then deducts the fee sent from the plug and pays to various off-chain actors. Plugs need to pay a fee to off-chain actors to get messages included in a packet to be executed on the destination chain. More on Fees here. Socket encodes key parameters into a message and hashes the encoded data. It then calls the capacitor and stores the hashed message in the capacitor. This emits a MessageAdded event. The message is stored in the capacitor until it can be emitted. Capacitors are chain specific and all messages to be sent to respective destination chains get aggregated in a given capacitor. Periodically, Off-chain transmitters will call seal() method on the capacitor which seals all stored messages into a packet and emits a Sealed event for the packet. This event is then picked up by transmitters that propose this packet on the destination chain. More on this below ","version":"Next","tagName":"h3"},{"title":"Receiving a message​","type":1,"pageTitle":"Lifecycle","url":"/Learn/lifecycle#receiving-a-message","content":"Once the packet is sealed on the source chain, the transmitter proposes this sealed packet to Socket on the destination chain. This includes the packetId, root, switchboard &amp; signature. Sending the signature separately allows the transmitter to sign messages from an authorized address, but be relayed by anyone. The transmitter proposes the packet for specified Switchboard and a packetCount is assigned to this proposal. If the address proposing the packet is a valid transmitter, the packet proposal is successful. The packet is stored in a mapping packetIdRoots and a PacketProposed event is emitted.  Once a packet is proposed, depending on the Switchboard used, the packet's validity is verified by watchers. More on this here. Once the packet is verified, executors then call execute on a message. During the execution of the message, the following is checked : The message is included in a packet (Decapacitor)The packet has been verified by the switchboard and exists on the source chain (Switchboard)  If these are verified, then the message can be executed. Executors call the execute() method on Socket which checks if the above cases are verified and calls the inbound method on the destination plug. It passes the designated payload to the Plug, which can be arbitrarily executed. In case the message cannot be executed due to insufficient gas limit or other errors, Socket will re-try execution periodically. More in Execution Failure. ","version":"Next","tagName":"h3"}]