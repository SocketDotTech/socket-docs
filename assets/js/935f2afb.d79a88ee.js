"use strict";(self.webpackChunkdatalayer_docs=self.webpackChunkdatalayer_docs||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"defaultSidebar":[{"type":"link","label":"What is SocketDL?","href":"/introduction","docId":"introduction"},{"type":"category","label":"Build on DL","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Speed Run DL","href":"/Build/hello-world","docId":"Build/hello-world"},{"type":"category","label":"Setup : Getting Started","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Configuring Plugs","href":"/Build/contract-setup/configuring-plugs","docId":"Build/contract-setup/configuring-plugs"},{"type":"link","label":"Sending messages","href":"/Build/contract-setup/sending","docId":"Build/contract-setup/sending"},{"type":"link","label":"Receiving messages","href":"/Build/contract-setup/receiving","docId":"Build/contract-setup/receiving"}]},{"type":"link","label":"Testing integration","href":"/Build/testing-dl","docId":"Build/testing-dl"},{"type":"category","label":"Examples","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"App Chain Bridge","href":"/Build/ExampleSection/app-chain-bridge","docId":"Build/ExampleSection/app-chain-bridge"},{"type":"link","label":"Universal ERC20","href":"/Build/ExampleSection/example-uniERC20","docId":"Build/ExampleSection/example-uniERC20"},{"type":"link","label":"Universal ERC721","href":"/Build/ExampleSection/example-uniERC721","docId":"Build/ExampleSection/example-uniERC721"},{"type":"link","label":"More Examples","href":"/Build/ExampleSection/dl-examples","docId":"Build/ExampleSection/dl-examples"}],"href":"/category/examples"}]},{"type":"category","label":"Dev Resources","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Contract Addresses","href":"/dev-resources/deployment-addresses","docId":"dev-resources/deployment-addresses"},{"type":"category","label":"Tutorials","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Counter Tutorial","href":"/dev-resources/TutorialSection/example-counter","docId":"dev-resources/TutorialSection/example-counter"},{"type":"link","label":"Message Failure & Retry","href":"/dev-resources/TutorialSection/retry-execute","docId":"dev-resources/TutorialSection/retry-execute"}],"href":"/category/tutorials"},{"type":"link","label":"Error Messages","href":"/dev-resources/errors","docId":"dev-resources/errors"},{"type":"category","label":"API Reference","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Check Connection","href":"/dev-resources/APIReference/check-connection","docId":"dev-resources/APIReference/check-connection"},{"type":"link","label":"Estimate Fees","href":"/dev-resources/APIReference/estimate-fees","docId":"dev-resources/APIReference/estimate-fees"},{"type":"link","label":"Track Message Status","href":"/dev-resources/APIReference/track-status","docId":"dev-resources/APIReference/track-status"}],"href":"/category/api-reference"},{"type":"category","label":"Interfaces","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"IPlug","href":"/dev-resources/Interfaces/IPlug","docId":"dev-resources/Interfaces/IPlug"},{"type":"link","label":"ISocket","href":"/dev-resources/Interfaces/ISocket","docId":"dev-resources/Interfaces/ISocket"},{"type":"link","label":"ISwitchboard","href":"/dev-resources/Interfaces/ISwitchboard","docId":"dev-resources/Interfaces/ISwitchboard"}],"href":"/category/interfaces"},{"type":"category","label":"Messaging Latency","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Fast","href":"/dev-resources/MessagingLatency/latency-fast","docId":"dev-resources/MessagingLatency/latency-fast"},{"type":"link","label":"Native","href":"/dev-resources/MessagingLatency/latency-native","docId":"dev-resources/MessagingLatency/latency-native"},{"type":"link","label":"Optimistic","href":"/dev-resources/MessagingLatency/latency-optimistic","docId":"dev-resources/MessagingLatency/latency-optimistic"}]}]},{"type":"category","label":"Learn about DL","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Glossary","href":"/Learn/glossary","docId":"Learn/glossary"},{"type":"link","label":"Protocol Design","href":"/Learn/protocol-design","docId":"Learn/protocol-design"},{"type":"link","label":"Lifecycle","href":"/Learn/lifecycle","docId":"Learn/lifecycle"},{"type":"category","label":"Components","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Capacitors","href":"/Learn/Components/Capacitors","docId":"Learn/Components/Capacitors"},{"type":"link","label":"Packet","href":"/Learn/Components/Packet","docId":"Learn/Components/Packet"},{"type":"link","label":"Plugs","href":"/Learn/Components/Plugs","docId":"Learn/Components/Plugs"},{"type":"link","label":"Switchboards","href":"/Learn/Components/Switchboards","docId":"Learn/Components/Switchboards"},{"type":"link","label":"TransmitManager","href":"/Learn/Components/TransmitManager","docId":"Learn/Components/TransmitManager"}],"href":"/category/components"},{"type":"category","label":"Concepts","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Fees","href":"/Learn/Concepts/fees","docId":"Learn/Concepts/fees"},{"type":"link","label":"Tracking Messages & Packets","href":"/Learn/Concepts/learn-tracking","docId":"Learn/Concepts/learn-tracking"}]},{"type":"link","label":"Off-Chain Agents","href":"/Learn/OffChain-Agents","docId":"Learn/OffChain-Agents"},{"type":"link","label":"Ownership","href":"/Learn/Ownership","docId":"Learn/Ownership"}],"href":"/category/learn-about-dl"}]},"docs":{"Build/contract-setup/configuring-plugs":{"id":"Build/contract-setup/configuring-plugs","title":"Configuring Plugs","description":"Connecting your cross-chain smart contracts (i.e. Plugs) is as easy as creating a Plug on chain A and chain B, connecting both Plugs to their chain\'s canonical Socket deployment, and configuring both Plugs to reference one another.","sidebar":"defaultSidebar"},"Build/contract-setup/receiving":{"id":"Build/contract-setup/receiving","title":"Receiving messages","description":"Plugs on destination network need to implement inbound() to handle incoming messages.","sidebar":"defaultSidebar"},"Build/contract-setup/sending":{"id":"Build/contract-setup/sending","title":"Sending messages","description":"Outbound method on the Socket contract deployed on all networks allows Plugs to send messages to other Plugs across chains. Checkout the below section to understand how to use it. If you want to read more on how sending messages in Socket works, read more here.","sidebar":"defaultSidebar"},"Build/ExampleSection/app-chain-bridge":{"id":"Build/ExampleSection/app-chain-bridge","title":"App Chain Bridge","description":"App Chain Bridge is a custom token bridge for App Chains or custom roll-ups. The bridge can be setup as a Lock-Mint bridge for existing tokens or a Burn-Mint bridge for tokens supporting Universal ERC20s","sidebar":"defaultSidebar"},"Build/ExampleSection/dl-examples":{"id":"Build/ExampleSection/dl-examples","title":"More Examples","description":"We have built a few examples and templates to make building on SocketDL easier. You can find all of them in the SocketDL-examples repo.","sidebar":"defaultSidebar"},"Build/ExampleSection/example-uniERC20":{"id":"Build/ExampleSection/example-uniERC20","title":"Universal ERC20","description":"Universal ERC-20 is an extension of ERC-20 token standard with cross-chain transfer capabilities, built on top of SocketDL. Universal ERC-20 has cross-chain transfers built-in. When sending the token between chains, it gets burnt on the sending chain and minted on the destination chain.","sidebar":"defaultSidebar"},"Build/ExampleSection/example-uniERC721":{"id":"Build/ExampleSection/example-uniERC721","title":"Universal ERC721","description":"Universal ERC-721 is an extension of ERC-721 token standard with cross-chain transfer capabilities, built on top of SocketDL.","sidebar":"defaultSidebar"},"Build/hello-world":{"id":"Build/hello-world","title":"Speed Run DL","description":"In this speed run tutorial, we\'ll be writing a contract to send/receive messages between chains. This is a code along tutorial, you can copy the code snippets into Remix or the dev environment of your choice. In case you are stuck, you can take peak at the entire code on GitHub. We\'ll be highlighting key functions and what they do throughout the tutorial. Some configuration variables have been hardcoded in the example.","sidebar":"defaultSidebar"},"Build/testing-dl":{"id":"Build/testing-dl","title":"Testing integration","description":"- Testing DL","sidebar":"defaultSidebar"},"dev-resources/APIReference/check-connection":{"id":"dev-resources/APIReference/check-connection","title":"Check Connection","description":"Checks if there\'s an active connection between PlugA on ChainA and PlugB on ChainB, and returns the type of switchboard used.","sidebar":"defaultSidebar"},"dev-resources/APIReference/estimate-fees":{"id":"dev-resources/APIReference/estimate-fees","title":"Estimate Fees","description":"Estimates the fees to be sent when calling outbound method on the contract. The fees to be paid are in the native token of the source chain. The fees can be calculated off-chain as well as on-chain, making SocketDL a smart contract first messaging protocol.","sidebar":"defaultSidebar"},"dev-resources/APIReference/track-status":{"id":"dev-resources/APIReference/track-status","title":"Track Message Status","description":"Tracks the status of a message","sidebar":"defaultSidebar"},"dev-resources/deployment-addresses":{"id":"dev-resources/deployment-addresses","title":"Contract Addresses","description":"Find Addresses","sidebar":"defaultSidebar"},"dev-resources/errors":{"id":"dev-resources/errors","title":"Error Messages","description":"| Error                    | Signature    | Description                                                                                                     |","sidebar":"defaultSidebar"},"dev-resources/Interfaces/IPlug":{"id":"dev-resources/Interfaces/IPlug","title":"IPlug","description":"","sidebar":"defaultSidebar"},"dev-resources/Interfaces/ISocket":{"id":"dev-resources/Interfaces/ISocket","title":"ISocket","description":"Required by Plugs for the following :","sidebar":"defaultSidebar"},"dev-resources/Interfaces/ISwitchboard":{"id":"dev-resources/Interfaces/ISwitchboard","title":"ISwitchboard","description":"Switchboards are required to have this interface to interact with Socket","sidebar":"defaultSidebar"},"dev-resources/MessagingLatency/latency-fast":{"id":"dev-resources/MessagingLatency/latency-fast","title":"Fast","description":"\x3c!--","sidebar":"defaultSidebar"},"dev-resources/MessagingLatency/latency-native":{"id":"dev-resources/MessagingLatency/latency-native","title":"Native","description":"Mainnet","sidebar":"defaultSidebar"},"dev-resources/MessagingLatency/latency-optimistic":{"id":"dev-resources/MessagingLatency/latency-optimistic","title":"Optimistic","description":"Mainnet","sidebar":"defaultSidebar"},"dev-resources/TutorialSection/example-counter":{"id":"dev-resources/TutorialSection/example-counter","title":"Counter Tutorial","description":"In this tutorial, we\'ll explore how to build and deploy a cross-chain counter. The cross-chain counter lets users update the value of the counter on one chain from another.","sidebar":"defaultSidebar"},"dev-resources/TutorialSection/retry-execute":{"id":"dev-resources/TutorialSection/retry-execute","title":"Message Failure & Retry","description":"Message execution may fail on the destination chain for the following reasons :","sidebar":"defaultSidebar"},"introduction":{"id":"introduction","title":"What is SocketDL?","description":"Socket Data Layer (SocketDL) is an arbitrary message passing protocol part of Socket\'s Interoperability stack.","sidebar":"defaultSidebar"},"Learn/Components/Capacitors":{"id":"Learn/Components/Capacitors","title":"Capacitors","description":"Capacitors are Socket Protocol defined Accumulators that accumulate or batch messages together for better gas efficiency. They are inspired by Capacitors in electrical circuits that store electrical-charges. Capacitors allow for in-protocol batching per switchboard, more messages queued equals more savings per message","sidebar":"defaultSidebar"},"Learn/Components/Packet":{"id":"Learn/Components/Packet","title":"Packet","description":"Packet is a cryptographic representation of PackedMessages. Capacitor produces Packets as soon as PackedMessages are added to it.","sidebar":"defaultSidebar"},"Learn/Components/Plugs":{"id":"Learn/Components/Plugs","title":"Plugs","description":"Smart contracts that connect to Socket to send messages to each other across chains are called Plugs. Before your Plugs can communicate to each other directly, you need to connect to Socket and inform Socket about your sibling Plugs. Plugs must \u201cconnect\u201d or get \u201cplugged into\u201d Socket for each unique sibling network for sending/receiving messages.","sidebar":"defaultSidebar"},"Learn/Components/Switchboards":{"id":"Learn/Components/Switchboards","title":"Switchboards","description":"Plugs connect to Socket via Switchboards(just like in real life). Switchboards are like open-source permissionless configuration bundles that plugs can opt into OR build their own configuration bundles.","sidebar":"defaultSidebar"},"Learn/Components/TransmitManager":{"id":"Learn/Components/TransmitManager","title":"TransmitManager","description":"As messages get accumulated by the capacitor, transmitters can seal the capacitors whenever it\'s ready to discharge to seal the Packet and create","sidebar":"defaultSidebar"},"Learn/Concepts/fees":{"id":"Learn/Concepts/fees","title":"Fees","description":"\x3c!--","sidebar":"defaultSidebar"},"Learn/Concepts/learn-tracking":{"id":"Learn/Concepts/learn-tracking","title":"Tracking Messages & Packets","description":"\x3c!-- - Tracking","sidebar":"defaultSidebar"},"Learn/glossary":{"id":"Learn/glossary","title":"Glossary","description":"We have introduced a lot of new terms and that is by design. We think for something as critical as AMB\'s nothing should be assumed or taken for-granted. We think these new terms are accurate and will encourage people to look into the docs/code and discourage assumptions.","sidebar":"defaultSidebar"},"Learn/lifecycle":{"id":"Learn/lifecycle","title":"Lifecycle","description":"In this section, we dive deeper into the main interactions between Plugs and Socket","sidebar":"defaultSidebar"},"Learn/OffChain-Agents":{"id":"Learn/OffChain-Agents","title":"Off-Chain Agents","description":"There are a couple of off-chain agents running at all times to process cross-chain messages, this section will outline some of those. The only 2 cross-chain agents that are part of Socket Protocol are the following:","sidebar":"defaultSidebar"},"Learn/Ownership":{"id":"Learn/Ownership","title":"Ownership","description":"We strongly believe that contracts should be immutable, non-upgradable, upgrades should be opt-in by clients. We have clear roles on the contract and plans on how to remove them. All roles are listed in the AccessRoles.sol contract","sidebar":"defaultSidebar"},"Learn/protocol-design":{"id":"Learn/protocol-design","title":"Protocol Design","description":"Introduction","sidebar":"defaultSidebar"}}}')}}]);